/*
 * Pax FFI - C bindings for the Pax format library
 * Version: 2.0.0-beta.1 (Request for Comments)
 *
 * This header provides a C-compatible API for parsing and manipulating
 * Pax documents from languages like C# via FFI.
 */

#ifdef __cplusplus
extern "C" {
#endif


#ifndef PAX_FFI_H
#define PAX_FFI_H

/* Generated with cbindgen:0.27.0 */

/* Warning: this file is autogenerated by cbindgen. Do not modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Value type enumeration
 */
typedef enum PaxValueType {
  PAX_VALUE_TYPE_NULL = 0,
  PAX_VALUE_TYPE_BOOL = 1,
  PAX_VALUE_TYPE_INT = 2,
  PAX_VALUE_TYPE_U_INT = 3,
  PAX_VALUE_TYPE_FLOAT = 4,
  PAX_VALUE_TYPE_STRING = 5,
  PAX_VALUE_TYPE_BYTES = 6,
  PAX_VALUE_TYPE_ARRAY = 7,
  PAX_VALUE_TYPE_OBJECT = 8,
  PAX_VALUE_TYPE_MAP = 9,
  PAX_VALUE_TYPE_REF = 10,
  PAX_VALUE_TYPE_TAGGED = 11,
  PAX_VALUE_TYPE_TIMESTAMP = 12,
} PaxValueType;

/**
 * Opaque handle to a Pax document
 */
typedef struct PaxDocument PaxDocument;

/**
 * Opaque handle to a binary reader
 */
typedef struct PaxReader PaxReader;

/**
 * Opaque handle to a Pax value
 */
typedef struct PaxValue PaxValue;

/**
 * Result type for FFI operations
 */
typedef struct PaxResult {
  bool success;
  char *error_message;
} PaxResult;

/**
 * Get the last error message.
 * Returns NULL if no error. Caller must free with pax_string_free.
 */
char *pax_get_last_error(void);

/**
 * Clear the last error message.
 */
void pax_clear_error(void);

/**
 * Parse a Pax text document from a string.
 * Returns NULL on error. Use pax_get_last_error() for error details.
 */
struct PaxDocument *pax_parse(const char *text);

/**
 * Parse a Pax text document from a file path.
 * Returns NULL on error. Use pax_get_last_error() for error details.
 */
struct PaxDocument *pax_parse_file(const char *path);

/**
 * Free a Pax document.
 */
void pax_document_free(struct PaxDocument *doc);

/**
 * Get a value from the document by key.
 * Returns NULL if the key doesn't exist.
 */
struct PaxValue *pax_document_get(const struct PaxDocument *doc, const char *key);

/**
 * Get all keys in the document.
 * Returns a NULL-terminated array of strings. Caller must free with pax_string_array_free.
 */
char **pax_document_keys(const struct PaxDocument *doc);

/**
 * Convert document to Pax text format with schema definitions.
 * This is the default output format that includes @struct definitions.
 * Caller must free the returned string with pax_string_free.
 */
char *pax_document_to_text(const struct PaxDocument *doc);

/**
 * Convert document to Pax text format without schema definitions (data only).
 * Use this when you only want the data portion without @struct definitions.
 * Caller must free the returned string with pax_string_free.
 */
char *pax_document_to_text_data_only(const struct PaxDocument *doc);

/**
 * Compile document to binary format and write to file.
 */
struct PaxResult pax_document_compile(const struct PaxDocument *doc,
                                      const char *path,
                                      bool compress);

/**
 * Parse a JSON string to create a Pax document with automatic schema inference.
 * Detects uniform object arrays and creates @struct definitions.
 * Returns NULL on error. Use pax_get_last_error() for error details.
 */
struct PaxDocument *pax_document_from_json(const char *json);

/**
 * Convert a Pax document to pretty-printed JSON.
 * Caller must free the returned string with pax_string_free.
 * Returns NULL on error. Use pax_get_last_error() for error details.
 */
char *pax_document_to_json(const struct PaxDocument *doc);

/**
 * Convert a Pax document to compact JSON (no extra whitespace).
 * Caller must free the returned string with pax_string_free.
 * Returns NULL on error. Use pax_get_last_error() for error details.
 */
char *pax_document_to_json_compact(const struct PaxDocument *doc);

/**
 * Get the type of a value.
 */
enum PaxValueType pax_value_type(const struct PaxValue *value);

/**
 * Free a Pax value.
 */
void pax_value_free(struct PaxValue *value);

/**
 * Get boolean value. Returns false if not a bool.
 */
bool pax_value_as_bool(const struct PaxValue *value);

/**
 * Get integer value. Returns 0 if not an int.
 */
int64_t pax_value_as_int(const struct PaxValue *value);

/**
 * Get unsigned integer value. Returns 0 if not a uint.
 */
uint64_t pax_value_as_uint(const struct PaxValue *value);

/**
 * Get float value. Returns 0.0 if not a float.
 */
double pax_value_as_float(const struct PaxValue *value);

/**
 * Get string value. Returns NULL if not a string.
 * Caller must free with pax_string_free.
 */
char *pax_value_as_string(const struct PaxValue *value);

/**
 * Get timestamp value (Unix milliseconds). Returns 0 if not a timestamp.
 */
int64_t pax_value_as_timestamp(const struct PaxValue *value);

/**
 * Get bytes length. Returns 0 if not bytes.
 */
uintptr_t pax_value_bytes_len(const struct PaxValue *value);

/**
 * Get bytes data pointer. Returns NULL if not bytes.
 * The returned pointer is valid only while the PaxValue is alive.
 * Do not free this pointer directly.
 */
const uint8_t *pax_value_bytes_data(const struct PaxValue *value);

/**
 * Get reference name. Returns NULL if not a ref.
 * Caller must free with pax_string_free.
 */
char *pax_value_ref_name(const struct PaxValue *value);

/**
 * Get tag name from a tagged value. Returns NULL if not tagged.
 * Caller must free with pax_string_free.
 */
char *pax_value_tag_name(const struct PaxValue *value);

/**
 * Get inner value from a tagged value. Returns NULL if not tagged.
 * Caller must free with pax_value_free.
 */
struct PaxValue *pax_value_tag_value(const struct PaxValue *value);

/**
 * Get map length. Returns 0 if not a map.
 */
uintptr_t pax_value_map_len(const struct PaxValue *value);

/**
 * Get map entry key by index. Returns NULL if out of bounds or not a map.
 * Caller must free with pax_value_free.
 */
struct PaxValue *pax_value_map_get_key(const struct PaxValue *value, uintptr_t index);

/**
 * Get map entry value by index. Returns NULL if out of bounds or not a map.
 * Caller must free with pax_value_free.
 */
struct PaxValue *pax_value_map_get_value(const struct PaxValue *value, uintptr_t index);

/**
 * Get array length. Returns 0 if not an array.
 */
uintptr_t pax_value_array_len(const struct PaxValue *value);

/**
 * Get array element by index. Returns NULL if out of bounds or not an array.
 */
struct PaxValue *pax_value_array_get(const struct PaxValue *value, uintptr_t index);

/**
 * Get object field by key. Returns NULL if not found or not an object.
 */
struct PaxValue *pax_value_object_get(const struct PaxValue *value, const char *key);

/**
 * Get object keys. Returns NULL-terminated array.
 * Caller must free with pax_string_array_free.
 */
char **pax_value_object_keys(const struct PaxValue *value);

/**
 * Open a binary Pax file for reading (reads file into memory).
 * Returns NULL on error. Use pax_get_last_error() for error details.
 */
struct PaxReader *pax_reader_open(const char *path);

/**
 * Open a binary Pax file with memory mapping (zero-copy access).
 * This is more efficient for large files as the OS handles paging.
 * Returns NULL on error. Use pax_get_last_error() for error details.
 *
 * # Safety
 * The file must not be modified while the reader is open.
 */
struct PaxReader *pax_reader_open_mmap(const char *path);

/**
 * Free a binary reader.
 */
void pax_reader_free(struct PaxReader *reader);

/**
 * Get a value from a binary file by key.
 */
struct PaxValue *pax_reader_get(const struct PaxReader *reader, const char *key);

/**
 * Get all keys from a binary file.
 */
char **pax_reader_keys(const struct PaxReader *reader);

/**
 * Get the number of schemas in a binary file.
 */
uintptr_t pax_reader_schema_count(const struct PaxReader *reader);

/**
 * Get a schema name by index.
 * Caller must free the returned string with pax_string_free.
 */
char *pax_reader_schema_name(const struct PaxReader *reader, uintptr_t index);

/**
 * Get the number of fields in a schema.
 */
uintptr_t pax_reader_schema_field_count(const struct PaxReader *reader, uintptr_t schema_index);

/**
 * Get a field name from a schema.
 * Caller must free the returned string with pax_string_free.
 */
char *pax_reader_schema_field_name(const struct PaxReader *reader,
                                   uintptr_t schema_index,
                                   uintptr_t field_index);

/**
 * Get a field's base type from a schema.
 * Caller must free the returned string with pax_string_free.
 */
char *pax_reader_schema_field_type(const struct PaxReader *reader,
                                   uintptr_t schema_index,
                                   uintptr_t field_index);

/**
 * Check if a field is nullable.
 */
bool pax_reader_schema_field_nullable(const struct PaxReader *reader,
                                      uintptr_t schema_index,
                                      uintptr_t field_index);

/**
 * Check if a field is an array type.
 */
bool pax_reader_schema_field_is_array(const struct PaxReader *reader,
                                      uintptr_t schema_index,
                                      uintptr_t field_index);

/**
 * Free a string returned by the library.
 */
void pax_string_free(char *s);

/**
 * Free a string array returned by the library.
 */
void pax_string_array_free(char **arr);

/**
 * Free a PaxResult's error message if present.
 */
void pax_result_free(struct PaxResult *result);

/**
 * Get the library version string.
 */
const char *pax_version(void);

#endif  /* PAX_FFI_H */

#ifdef __cplusplus
}
#endif

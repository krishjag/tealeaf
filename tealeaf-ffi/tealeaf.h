/*
 * TeaLeaf FFI - C bindings for the TeaLeaf format library
 * Version: 2.0.0-beta.1 (Request for Comments)
 *
 * This header provides a C-compatible API for parsing and manipulating
 * TeaLeaf documents from languages like C# via FFI.
 */

#ifdef __cplusplus
extern "C" {
#endif


#ifndef TEALEAF_FFI_H
#define TEALEAF_FFI_H

/* Generated with cbindgen:0.27.0 */

/* Warning: this file is autogenerated by cbindgen. Do not modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Value type enumeration
 */
typedef enum TLValueType {
  TL_VALUE_TYPE_NULL = 0,
  TL_VALUE_TYPE_BOOL = 1,
  TL_VALUE_TYPE_INT = 2,
  TL_VALUE_TYPE_U_INT = 3,
  TL_VALUE_TYPE_FLOAT = 4,
  TL_VALUE_TYPE_STRING = 5,
  TL_VALUE_TYPE_BYTES = 6,
  TL_VALUE_TYPE_ARRAY = 7,
  TL_VALUE_TYPE_OBJECT = 8,
  TL_VALUE_TYPE_MAP = 9,
  TL_VALUE_TYPE_REF = 10,
  TL_VALUE_TYPE_TAGGED = 11,
  TL_VALUE_TYPE_TIMESTAMP = 12,
} TLValueType;

/**
 * Opaque handle to a TeaLeaf document
 */
typedef struct TLDocument TLDocument;

/**
 * Opaque handle to a binary reader
 */
typedef struct TLReader TLReader;

/**
 * Opaque handle to a TeaLeaf value
 */
typedef struct TLValue TLValue;

/**
 * Result type for FFI operations
 */
typedef struct TLResult {
  bool success;
  char *error_message;
} TLResult;

/**
 * Get the last error message.
 * Returns NULL if no error. Caller must free with tl_string_free.
 */
char *tl_get_last_error(void);

/**
 * Clear the last error message.
 */
void tl_clear_error(void);

/**
 * Parse a TeaLeaf text document from a string.
 * Returns NULL on error. Use tl_get_last_error() for error details.
 */
struct TLDocument *tl_parse(const char *text);

/**
 * Parse a TeaLeaf text document from a file path.
 * Returns NULL on error. Use tl_get_last_error() for error details.
 */
struct TLDocument *tl_parse_file(const char *path);

/**
 * Free a TeaLeaf document.
 */
void tl_document_free(struct TLDocument *doc);

/**
 * Get a value from the document by key.
 * Returns NULL if the key doesn't exist.
 */
struct TLValue *tl_document_get(const struct TLDocument *doc, const char *key);

/**
 * Get all keys in the document.
 * Returns a NULL-terminated array of strings. Caller must free with tl_string_array_free.
 */
char **tl_document_keys(const struct TLDocument *doc);

/**
 * Convert document to TeaLeaf text format with schema definitions.
 * This is the default output format that includes @struct definitions.
 * Caller must free the returned string with tl_string_free.
 */
char *tl_document_to_text(const struct TLDocument *doc);

/**
 * Convert document to TeaLeaf text format without schema definitions (data only).
 * Use this when you only want the data portion without @struct definitions.
 * Caller must free the returned string with tl_string_free.
 */
char *tl_document_to_text_data_only(const struct TLDocument *doc);

/**
 * Compile document to binary format and write to file.
 */
struct TLResult tl_document_compile(const struct TLDocument *doc, const char *path, bool compress);

/**
 * Parse a JSON string to create a TeaLeaf document with automatic schema inference.
 * Detects uniform object arrays and creates @struct definitions.
 * Returns NULL on error. Use tl_get_last_error() for error details.
 */
struct TLDocument *tl_document_from_json(const char *json);

/**
 * Convert a TeaLeaf document to pretty-printed JSON.
 * Caller must free the returned string with tl_string_free.
 * Returns NULL on error. Use tl_get_last_error() for error details.
 */
char *tl_document_to_json(const struct TLDocument *doc);

/**
 * Convert a TeaLeaf document to compact JSON (no extra whitespace).
 * Caller must free the returned string with tl_string_free.
 * Returns NULL on error. Use tl_get_last_error() for error details.
 */
char *tl_document_to_json_compact(const struct TLDocument *doc);

/**
 * Get the type of a value.
 */
enum TLValueType tl_value_type(const struct TLValue *value);

/**
 * Free a TeaLeaf value.
 */
void tl_value_free(struct TLValue *value);

/**
 * Get boolean value. Returns false if not a bool.
 */
bool tl_value_as_bool(const struct TLValue *value);

/**
 * Get integer value. Returns 0 if not an int.
 */
int64_t tl_value_as_int(const struct TLValue *value);

/**
 * Get unsigned integer value. Returns 0 if not a uint.
 */
uint64_t tl_value_as_uint(const struct TLValue *value);

/**
 * Get float value. Returns 0.0 if not a float.
 */
double tl_value_as_float(const struct TLValue *value);

/**
 * Get string value. Returns NULL if not a string.
 * Caller must free with tl_string_free.
 */
char *tl_value_as_string(const struct TLValue *value);

/**
 * Get timestamp value (Unix milliseconds). Returns 0 if not a timestamp.
 */
int64_t tl_value_as_timestamp(const struct TLValue *value);

/**
 * Get bytes length. Returns 0 if not bytes.
 */
uintptr_t tl_value_bytes_len(const struct TLValue *value);

/**
 * Get bytes data pointer. Returns NULL if not bytes.
 * The returned pointer is valid only while the TLValue is alive.
 * Do not free this pointer directly.
 */
const uint8_t *tl_value_bytes_data(const struct TLValue *value);

/**
 * Get reference name. Returns NULL if not a ref.
 * Caller must free with tl_string_free.
 */
char *tl_value_ref_name(const struct TLValue *value);

/**
 * Get tag name from a tagged value. Returns NULL if not tagged.
 * Caller must free with tl_string_free.
 */
char *tl_value_tag_name(const struct TLValue *value);

/**
 * Get inner value from a tagged value. Returns NULL if not tagged.
 * Caller must free with tl_value_free.
 */
struct TLValue *tl_value_tag_value(const struct TLValue *value);

/**
 * Get map length. Returns 0 if not a map.
 */
uintptr_t tl_value_map_len(const struct TLValue *value);

/**
 * Get map entry key by index. Returns NULL if out of bounds or not a map.
 * Caller must free with tl_value_free.
 */
struct TLValue *tl_value_map_get_key(const struct TLValue *value, uintptr_t index);

/**
 * Get map entry value by index. Returns NULL if out of bounds or not a map.
 * Caller must free with tl_value_free.
 */
struct TLValue *tl_value_map_get_value(const struct TLValue *value, uintptr_t index);

/**
 * Get array length. Returns 0 if not an array.
 */
uintptr_t tl_value_array_len(const struct TLValue *value);

/**
 * Get array element by index. Returns NULL if out of bounds or not an array.
 */
struct TLValue *tl_value_array_get(const struct TLValue *value, uintptr_t index);

/**
 * Get object field by key. Returns NULL if not found or not an object.
 */
struct TLValue *tl_value_object_get(const struct TLValue *value, const char *key);

/**
 * Get object keys. Returns NULL-terminated array.
 * Caller must free with tl_string_array_free.
 */
char **tl_value_object_keys(const struct TLValue *value);

/**
 * Open a binary TeaLeaf file for reading (reads file into memory).
 * Returns NULL on error. Use tl_get_last_error() for error details.
 */
struct TLReader *tl_reader_open(const char *path);

/**
 * Open a binary TeaLeaf file with memory mapping (zero-copy access).
 * This is more efficient for large files as the OS handles paging.
 * Returns NULL on error. Use tl_get_last_error() for error details.
 *
 * # Safety
 * The file must not be modified while the reader is open.
 */
struct TLReader *tl_reader_open_mmap(const char *path);

/**
 * Free a binary reader.
 */
void tl_reader_free(struct TLReader *reader);

/**
 * Get a value from a binary file by key.
 */
struct TLValue *tl_reader_get(const struct TLReader *reader, const char *key);

/**
 * Get all keys from a binary file.
 */
char **tl_reader_keys(const struct TLReader *reader);

/**
 * Get the number of schemas in a binary file.
 */
uintptr_t tl_reader_schema_count(const struct TLReader *reader);

/**
 * Get a schema name by index.
 * Caller must free the returned string with tl_string_free.
 */
char *tl_reader_schema_name(const struct TLReader *reader, uintptr_t index);

/**
 * Get the number of fields in a schema.
 */
uintptr_t tl_reader_schema_field_count(const struct TLReader *reader, uintptr_t schema_index);

/**
 * Get a field name from a schema.
 * Caller must free the returned string with tl_string_free.
 */
char *tl_reader_schema_field_name(const struct TLReader *reader,
                                  uintptr_t schema_index,
                                  uintptr_t field_index);

/**
 * Get a field's base type from a schema.
 * Caller must free the returned string with tl_string_free.
 */
char *tl_reader_schema_field_type(const struct TLReader *reader,
                                  uintptr_t schema_index,
                                  uintptr_t field_index);

/**
 * Check if a field is nullable.
 */
bool tl_reader_schema_field_nullable(const struct TLReader *reader,
                                     uintptr_t schema_index,
                                     uintptr_t field_index);

/**
 * Check if a field is an array type.
 */
bool tl_reader_schema_field_is_array(const struct TLReader *reader,
                                     uintptr_t schema_index,
                                     uintptr_t field_index);

/**
 * Free a string returned by the library.
 */
void tl_string_free(char *s);

/**
 * Free a string array returned by the library.
 */
void tl_string_array_free(char **arr);

/**
 * Free a TLResult's error message if present.
 */
void tl_result_free(struct TLResult *result);

/**
 * Get the library version string.
 */
const char *tl_version(void);

#endif  /* TEALEAF_FFI_H */

#ifdef __cplusplus
}
#endif
